# 객체 생성 패턴

자바스크립트에서는 객체 리터럴이나 생성자 함수를 사용하여 앚 쉽게 깨체를 만들 수 있다. 이 장에서는 좀더 나아가 객체를 생성하는 또다른 패턴들을 살펴볼 것이다. 
자바스크립트 언어는 간단하고 평이하다. 다른 언어에서는 네임스페이스나 모듈 패키지, 비공개 프로퍼티, 스태틱 멤버 등의 기능이 익숙하고 당연할지 몰라도, 자바스크립트에는 이런 것들을 위한 별도의 문법이 거의 없다. 이 장에서는 이러한 기능들을 구현하거나 대체하거나 또는 다른 관점에서 바라볼 수 있게 해주는 범용적인 패턴들에 대해 알아본다. 
네임스페이스 패턴, 의존 관계 선언, 모듈 패턴, 샌드박스 패턴등은 애플리케이션 코드를 정리하고 구조화할 수 있게 도와주고, 암묵적 전역의 영향력을 약화시킨다. 또한 비공개 멤버와 특권 멤버, 공개/비공개 스태틱 멤버, 객체 상수, 체이닝에 대해서도 다루고, 클래스와 비슷한 방식으로 생성자를 정의하는 방법도 하나 살펴본다.

## 네임스페이스 패턴

네임스페이스는 프로그램에서 필요로 하는 전역 변수의 개수를 줄이는 동시에 과도한 접두어를 사용하지 않고도 이름이 겹치지 않게 해준다. 
자바스크립트의 언어 문법에 내장되어 있지는 않지만, 네임스페이스는 꽤 쉽게 구현할 수 있는 기능이다. 수많은 함수, 객체, 변수들로 전역 유효범위를 어지럽히는 대신, 애플리케이션이나 랑이브러리를 위한 전역 객체를 하나 만들고 (단 하나만 만드는 것이 이상적이다.) 모든 기능을 이 객체에 추가하면 된다. 

다음 예제를 살펴보자 (수정 전 예제는 안티패턴[^1]이다.).

```javascript
// 수정 전: 전역 변수 5개

// 생성자 함수 2개
function Parent() {}
function Child() {}

// 변수 1개
var some_var = 1;

// 객체 2개
var module1 = {};
module.data = {a: 1, b: 2};
var module2 = {};
```

위와 같은 코드를 피랙터링 하기 위해서는 먼저 애플리케이션 전용 전역 객체, 이를테면 MYAPP을 생성한다. 그런 다음 모든 함수와 변수들을 이 전역 객체의 프로퍼티로 변경한다.

```javascript
// 수정 후 : 전역 변수 1개.

// 전역 객체
var MYAPP = {};

// todtjdwk
MYAPP.Parent = function () {};
MYAPP.Child = function () {};

// 변수
MYAPP.some_var = 1;

// 객체 컨테이너
MYAPP.modules = {};

// 객체들을 컨테이너 안에 추가한다.
MYAPP.modules.module1 = {};
MYAPP.modules.module1.data = {a: 1, b: 2};
MYAPP.modules.module2 = {};
```

전역 네임스페이스 객체의 이름은 애플리케이션 이름이나 라이브러리의 이름, 도메인명, 회사 이름 중에서 선택할 수도 있다. 흔히 코드를 읽는 사람 눈에 띄도록 *전역 객체 이름은 모두 대문자로 쓰는 명명 규칙*을 사용하기도 한다. (이 규칙은 상수를 쓸 때도 사용된다는 점을 주의하라.)

이 패턴은 코드에 네임스페이스를 지정해주며, 코드 내의 이름 충돌 뿐 아니라 이 코드와 같은 페이지에 존재하는 자바스크립트 라이브러리나 위짓 등 서드 파티 코드와의 이름 충돌도 방지해준다. 다양한 작업에 응용할 수 있으며, 매우 권장하는 패턴이다. 그러나 다음과 같은 단점도 존재한다.

  * 모든 변수와 함수에 접두어를 붙여야 하기 때문에 전체적으로 코드량이 약간 더 많아지고 따라서 다운로드해야 하는 파일 크기도 늘어난다. 
  * 전역 인스턴스가 단 하나뿐이기 때문에 코드의 어느 한 부분이 수정되어도 전역 인스턴스를 수정하게 된다. 즉 나머지 기능들도 갱신된 상태를 물려받는다.
  * 이름이 중첩되고 길어지므로 프로퍼티를 판별하기 위한 검색 작업도 길고 느려진다. 이 장의 뒷부분에서는 이 단점을 해결하는 샌드박스 패턴을 다룰 것이다.

## 범용 네임스페이스 함수

프로그램의 복잡도가 증가하고 코드의 각 부분들이 별개의 파일로 분리되어 선택적으로 문서에 포함되게 되면, 어떤 코드가 특정 네임스페이스나 그 내부의 프로퍼티를 처음으로 정의한다고 가정하기가 위험하다. 네임스페이스가 추가하려는 프로퍼티가 이미 존재할 수도 있고, 따라서 내용을 덮어쓰게 될 지도 모른다. 그러므로 네임스페이스를 생성하거나 프로퍼티를 추가하기 전에 먼저 이미 존재하는지 여부를 확인하는 것이 최선이다. 다음 예제를 보자.

```javascript
// 위험하다.
var MYAPP = {};

// 개선안
if (typeof MYAPP === 'undefined') {
  var MYAPP = {};
}

// 또는 더 짧게 쓸 수 있다.
var MYAPP = MYAPP || {};
```

이렇게 추가되는 확인 작업 때문에 상당량의 중복 코드가 생겨날 수 있다. 예를 들어 `MYAPP.modules.modules2` 를 정의하려면, 각 단계의 객체와 프로퍼티를 정의할 때마다 확인 작업을 거쳐야 하므로 코드가 세 번 중복된다. 따라서 네임스페이스 생성의 실제 작업을 맡아 줄 재사용 가능한 함수를 만들어두면 편리하다. 이 함수를 `namespace()`라 하고 다음과 같이 사용한다고 하자.

```javascript
// 네임스페이스 함수를 사용한다.
MYAPP.namespace('MYAPP.modules.module2');


// 위 코드는 다음과 같은 결과를 반환한다.
// var MYAPP = {
//   modules: {
//     module2: {}
//   }
// };

```

다음은 네임스페이스 함수를 구현한 예제다. 다음과 같은 방식은 해당 네임스페이스가 존재하면 덮어쓰지 않기 때문에 기존 코드를 망가뜨리지 않는다.

```javascript
var MYAPP = MYAPP || {};
MYAPP.namespace = function (ns_string) {
  var parts = ns_string.split('.'),
  parent = MYAPP,
  i;

  // 처음에 중복되는 전역 객체명은 제거한다.
  if (parts[0] === 'MYAPP') {
    parts = parts.slice(1);
  }
  for (i = 0; i < parts.length; i += 1) {
    // 프로퍼티가 존재하지 않으면 생성한다.
    if (typeof parent[parts[i]] === 'undefined') {
      parent[parts[i]] = {};
    }
    parent = parent[parts[i]];
  }
  return parent;
};
```

이 코드는 다음 모든 예에서 사용할 수 있다. 
```javascript 
// 반환 값을 지역 변수에 할당한다.
var module2 = MYAPP.namespace('MYAPP.modules.module2') ;
module2 === MYAPP.modules.module2; // true

// 첫 부분의 'MYAPP'을 생략하고도 쓸 수 있다.
MYAPP.namespace('modules.module51');

// 아주 긴 네임스페이스를 만들어보자
MYAPP.namespace('once.upon.a.time.there.was.this.long.nested.property');
```


---

[^1]: 안티패턴 : 실제 많이 사용되는 **패턴**이지만 비효율적이거나 비생산적인 **패턴**을 의미한다. **안티패턴**은 1995년 앤드루 케이니그가 디자인 **패턴**을 참고하여 처음 사용한 말이다.