# 원시 타입과 참조 타입

개발자 대부분은 자바나 C# 같은 클래스 기반 언어를 사용하면서 객체지향 프로그래밍을 배운다. 하지만 이런 개발자들은 자바슼릡트를 배울 떄 갈피를 잡지 못하는 경우가 많은데 자바스크립트에서는 처음부터 클래스를 정의하지 않고도 코드를 작성할 수 있으며 필요에 따라 데이터 구조를 만들어서 사용한다. 클래스가 없으므로 패키지와 같이 클래스를 그룹으로 묶는 기능도 없다. 자바 같은 언어에서는 패키지 이름과 클래스 이름을 통해 사용할 객체의 종류와 프로젝트의 파일 및 폴더 구조를 정하지만, 자바스크립트에서는 백지 상태에서 프로그래밍을 시작하며 파일이든 폴더든 여러분이 원하는 대로 구성할 수 있다. 다른 언어의 파일 구조를 흉내 내는 이도 있고 자바스크립트의 유연함을 한껏 활용해 완전히 새로운 구조를 만들어내는 이도 있다. 아무런 지식이 없는 사람에게는 이러한 선택의 자유가 도리어 지나치게 느껴질 수도 있다. 하지만 익숙해지고 나면 여러분의 취향을 아주 쉽게 반영할 수 있을 정도로 자바스크립트가 매우 유연한 언어임을 깨닫게 될 것이다.

자바스크립트는 전통적인 객체지향 언어를 배운 사람도 쉽게 배울 수 있도록 언어의 중심을 객체에 두고 있다. 자바스크립트에서 데이터 대부분은 객체이거나 객체를 통해 접근하는 값이다. 자바스크립트는 함수조차 객체로 표현하며 덕분에 자바스크립트의 함수는 *일급 함수(first-class functions)* 이다.

객체를 다루고 이해할 수 있어야 자바스크립트를 전체적으로 이해할 수 있따. 자바스크립트에서 객체는 언제든 만들 수 있고 객체의 프로퍼티(property) 또한 원한다면 언제든 추가하거나 제거할 수 있다. 자바슼르비트의 객체는 매우 유연하여 다른 언어에서는 쉽게 사용할 수 없었던 독특하고 흥미로운 패턴도 만들 수 있다.

이 장에서는 자바스크립트에 있는 두 종류의 타입, 즉 원시 타입과 참조 타입에 대해 알아보고 다룰 것이다. 두 타입 모두 객체를 통해 접근하지만 서로 다르게 동작하므로 차이점을 익혀두는 것이 좋다. 

## 타입이란?

자바스크립트에 클래스라는 개념은 없지만 이를 대체할 타입이라는 개념이 존재하며 타입은 크게 두 종류로 구분한다. 하나는 단순한 데이터를 저장하는 *원시 타입*이고 다른 하나는 객체로서 저장되는 *참조 타입*이다. 참조 타입은 사실 메모리상의 주소를 가리킨다.

자바스크립트에서는 일관성을 유지하기 위해 원시 타입도 참조 타입처럼 다룰 수 있도록 되어 있는데 이 떄문에 이해하기 어려워진 면이 있다.


다른 프로그래밍 언어는, 원시 타입은 스택에 저장하고 참조는 힙에 저장하여 원시 타입과 참조 타입을 구분하고 있지만 자바스크립트는 그렇지 안핟. 자바스크립트에서는 *변수 객체(variable object)*의 스코프를 따라 변수를 추적한다. 원시 타입의 원시 값은 바로 변수 객체에 저장되지만 참조 타입에서 변수 객체에 저장되는 참조 값은 메모리에 있는 실제 객체를 가리키는 포인터(pointer)이다. 원시 값과 참조 값은 일견 비슷해 보이지만 상당히 다르게 동작한다. 이에 대해서는 나중에 설명할 것이다.

원시 타입과 참조 타입에도 여러 종류가 있다.

## 원시 타입

원시 타입(primitive type)은 true와 25처럼 있는 그대로 저장되는 간단한 데이터를 표현한다. 자바스크립트에는 다섯 종류의 원시 타입이 있다.

* Boolean(불리언): true 또는 false
* Number(숫자): 정수 또는 부동소수점 실수 값
* String(문자열): 한 쌍의 작은 따옴표 또는 큰 따옴표로 감싼 일련의 문자 (자바스크립트에는 문자 타입이 따로 없다.)
* Null : null이라는 값만 있는 원시 타입
* Undefined: undefined라는 값만 있는 타입 (undefined는 아무런 값도 할당되지 않은 변수에 할당되는 값이다.)

앞의 세 종류(불리언, 숫자, 문자열)는 빗스한 방식으로 동작하지만 뒤의 두 종류(null과 undefined)는 조금 다르게 동작한다. 그에 대해서는 이 장 전반에 걸쳐 다루도록 하겠다. 모든 원시 타입에는 값을 표현하는 리터럴(literal) 형식이 있다. 리터럴(literal)이란 코드에 직접 입력된 이름이나 가격처럼 변수에 저장되지 않은 값을 의미한다. 다음은 리터럴 형식을 사용한 각 타입의 예제이다. 

```javascript
// 문자열
var name = "Nicholas";
var selection = "a";

// 숫자
var count = 25;
var cost = 1.51;

//불리언
var found = true;

// null
var object = null;

// undefined
var flag = undefined;
var ref; // 자동으로 undefined가 할당된다.
```

다른 많은 언어와 마찬가지로 자바스크립트 변수에는 원시 타입의 값이 바로 저장된다(객체의 포인터가 아니다). 원시 값을 변수에 할당하면 값이 변수로 복사된다. 다시 말해 등호 기호를 사용해 어떤 변수를 다른 변수에 할당하면 두 변수 모두 자신만의 데이터를 가지게 된다는 뜻이다. 다음 예를 보자.

```javascript
var color1 = "red";
var color2 = color1;
```

이 코드에서 color1에는 "red"라는 값이 할당되었고 color2에는 color1의 값을 할당했다. 따라서 color2에는 "red"가 저장되었다. color1과 color2는 같은 값을 가지고 있지만 두 값은 완전히 별개의 ㄱ밧이며 color2에 아무런 영향을 주지 않고 color1의 값을 바꿀 수 있다. 물론 color2를 바꿀 때도 마찬가지로 color1에 아무런 영향을 주지 않는다. 이는 두 값이 각 값당 하나씩 할당된 서로 다른 영역에 저장되어 있기 때문이다.

원시 값을 가지고 있는 각 변수는 독립된 저장 공간을 사용하기 때문에 다른 변수의 값을 바꿔도 영향을 받지 않는다. 다음 예를 보자.

```javascript
var color1 = "red";
var color2 = color1;

console.log(color1); // "red"
console.log(color2); // "red"

color1 = "blue";

console.log(color1); // "blue"
console.log(color2); // "red"
```

이 코드에서 color1의 값은 "blue"로 바뀌었지만 color2는 여전히 원래대로 "red"를 유지한다.


### 원시 타입 종류 확인

원시 타입의 종류는 typeof 연산자를 사용해 확인할 수 있다. typeof 연산자를 변수에 사용하면 변수에 저장된 데이터의 타입을 문자열로 반환한다. typeof 연산자는 문자열, 숫자, 불리언, undefined와 잘 동작한다. 다음은 typeof 연산자를 여러 종류의 원시 값에 사용할 때 볼 수 있는 출력 결과이다.


```javascript
console.log(typeof "Nicholas"); // "string"
console.log(typeof 10);         // "number"
console.log(typeof 5.1);        // "number"
console.log(typeof true);       // "boolean"
console.log(typeof undefined);  // "undefined"
```

예상했듯이 문자열 값에 typeof 연산자를 사용하면 "string"을 반환하고 숫자 값에 사용하면 "number"를 반환한다. 이때, 숫자가 정수인지 실수인지는 상관없다. 불리언일 때는 "boolean"을 반환하고, 값이 undefined일 때는 "undefined"를 반환한다.

다만 null은 조금 까다롭다. 

다음 코드의 실행 결과를 처음 본 개발자라면 이해하기 어려운 것이 당연하다.

```javascript
console.log(typeof null); // "object"
```

typeof null을 실행하면 결과는 "object"이다. 그런데 null이 객체라는 까닭은 무엇일까? (사실 이는 자바스크립트 언어를 설계하고 관리하는 TC39 위원회에서 실수라고 인정했떤 부분이다. 덕분에 객체를 반환해야 할 때 null을 빈 객체 포인터처럼 생각할 수있지만 헷갈리는 것은 여전한다.)

이 같은 특성 때문에 null인지 아닌지를 확인할 때는 다음과 같이 null과 직접 비교하는 것이 가장 좋다.

```javascript
console.log(value === null); // true or false
```

### 원시 메소드

앞에서 본 값은 모두 원시 타입이지만, 문자열, 숫자, 불리어에는 사실 메소드가 존재한다(null과 undefined 타입에는 메소드가 없다). 특히 문자열에는 다음 예제에서 보듯이 유용한 메소드가 많다. 

```javascript
var middleOfName = name.substring(2, 5); // 두 번째부터 네 번째 문자까지 가져오기

var count = 10;
var fixedCount = count.toFixed(2); // "10.00"으로 변환
var hexCount = count.toString(16); // "a"로 변환

var flag = true;
var stringFlag = flag.toString(); // "true"로 변환
```


## 참조 타입

참조 타입은 자바스크립트 객체를 나타내며 클래스가 없는 자바스크립트라는 언어에서 클래스와 가장 가까운 개념이다. 참조 값은 참조 타입의 *인스턴스(instance)*이며 객체와 같은 말이다(이후 이 장에서는 참조 값을 객체(objects)라고 표현하겠다). 객체는 순서가 없는 *프로퍼티(property)*로 이루어져 있으며 프로퍼티는 이름(문자열)과 값으로 구성되어 있다. 프로퍼티의 값이 함수일 떄 이 프로퍼티를 가리켜 *메소드(method)* 라고 부른다. 사실 자바스크립트에서 함수 자체는 참조 값이므로 배열을 포함하고 있는 프로퍼티와 함수를 포함하고 있는 프로퍼티 사이에서 함수는 실행이 가능하다는 점만 빼면 차이가 거의 없다.

프로퍼티나 메소드를 다루려면 먼저 객체를 만들어야 한다.

### 객체 생성

객체를 만드는 것을 가리켜 *인스턴스화(instantiate)* 한다고 하는데 자바스크립트에서 인스턴스화 방법은 두 가지가 있다. 첫 번째 방법은 new 연산자와 생성자(constructor)를 사용하는 것이다(생성자는 사실 new 연산자와 함께 사용하여 객체를 만들 수 있는 함수일 뿐이다. 어떤 함수든 생성자가 될 수있다). 관례상 자바스크립트에서 생성자의 이름은 첫 글자를 대문자로 시자갛여 생성자가 아닌 다른 함수와 구분하도록 하고 있따. 예를 들어 다음 코드는 일반 객체(generic object)를 하나 작성하고 객체의 참조를 object 변수에 저장한다.

```javascript
var object = new Object();
```

참조 타입은 할당된 변수에 값을 직접 저장하지 않으므로 이 예제에서 object 변수에 저장된 값은 사실 객체 인스턴스가 아니라 객체가 있는 메모리상의 위치를 가리키는 포인터(또는 참조)이다. 이것이 바로 객체와 원시 값의 가장 큰 차이점인데 원시 값은 변수에 직접 값 자체가 저장된다.

객체를 변수에 할당하는 일은 사실 객체의 포인터를 할당한 셈이다. 다시 말해 어떤 변수를 다른 변수에 할당하면 두 변수는 모두 포인터의 복사본만 저장하고 있으므로 메모리상에서 똑같은 객체를 참조하게 된다. 예를 들어 다음 코드를 보자.

```javascript
var object1 = new Object();
var object2 = object1;
```

이 코드는 먼저 새로운 객체를 생성한 후(new 연산자 사용) object1 변수에 객체의 참조를 저장한다. 다음으로 object2에 object1의 값을 할당했다. 이를 통해 두 변수 모두 첫 번 째 줄에서 생성한 객체의 인스턴스를 가리키게 된다. 

### 객체 참조 제거

자바스크립트는 가비지 컬렉션(garbage collection) 기능이 있는 언어이므로 참조 타입을 사용할 때 메모리 할당에 대해 고민하지 않아도 된다. 하짐나 가비지 컬렉터(garbage collector)가 메모리를 해제할 수 있도록 사용하지 않는 객체에 대해서는 참조 제거(dereference)를 해두는 편이 좋다. 참조 제거를 할 때는 객체 변수에 null을 할당하는 방식이 가장 좋다.

```javascript
var object1 = new Objetct();
// 실행할 코드
object1 = null; // 참조 제거
```

이 코드는 object1 변수를 만들고 사용하다가 변수의 값에 null을 할당했다. 가비지 컬렉터는 메모리상의 객체 중 전혀 참조되어 있지 않은 것이 있으면 다른 용도로 이 메모리를 사용할 수 있도록 객체가 자치하고 있는 메모리를 없앤다(객체를 수백만 개씩 사용하는 대규모 애플리케이션에서는 객체의 참조 제거가 특히 중요하다).

### 프로퍼티 추가 및 제거

자바스크립트의 재미있는 특징 중 하나는 언제든 프로퍼티를 추가하거나 제거할 수 있다는 것이다. 다음 코드를 보자

```javascript
var object1 = new Object();
var object2 = object1;

object1.myCustomProperty = "Awesome!";
console.log(object2.myCustomProperty); // "Awesome!"
```

이 코드에서 myCustomProperty는 object에 "Awesome!" 이라는 값과 함께 추가되었따. object1과 object2는 같은 객체를 가리키고 있으므로 이 프로퍼티는 object2에서도 접근할 수 있다.
자바스크립트에는 일반 객체 참조 타입 외에도 자유롭게 사용할 수 있는 내장 타입이 몇 가지 더 있다.

## 내장 타입 인스턴스화

앞서 new Object()를 사용해 일반 객체를 생성하고 다루는 법에 대해 살펴보았다. 사실 자바스크립트에는 Object 타입 외에도 언어에서 기본적으로 제공하는 유용한 내장 참조 타입이 몇 가지 더 있다. 다른 내장 타입은 조금 더 특수한 용도로 사용할 수 있으며 언제든 인스턴스로 만들 수 있다.

내장 타입은 다음과 같다.

* Array : 숫자 인덱스 값을 가진 순차 목록
* Date : 날짜와 시간
* Error: 실행 중 발생하는 에러 (에러의 종류에 따라 더 구체적인 하위 에러 타입이 존재한다)
* Function: 함수
* Object: 일반적인 객체
* RegExp: 정규표현식


내장 참조 타입은 당므과 같이 new 연산자를 사용해 인스턴스로 만들 수 있다.

```javascript
var items = new Array();
var now = new Date();
var error = new Error("에러가 발생했습니다.");
var func = new Function("console.log('Hi');");
var object = new Object();
var re = new RegExp("\\d+");
```


### 리터럴 형식

일부 내장 참조 타입은 리터럴 형식도 사용할 수 있다. 리터럴(literal)은 new 연산자와 객체의 생성자를 사용하여 명시적으로 객체를 만들지 않고도 참조 값을 만들 수 있는 문법이다(이 장 초반에 문자열 리터럴, 숫자 리터럴, 불리언 리터럴, null 리터럴, undefined 리터럴 등 다양한 원시 값 리터럴을 보았을 것이다).

### 객체 및 배열 리터럴

객체는 중괄호 안에 새로 만들 객체의 프로퍼티를 정의하는 *객체 리터럴(object literal)* 문법을 사용해 만들 수 있다. 프로퍼티는 이름, 콜론, 값으로 이루어지며 프로퍼티 사이는 쉼표로 구분한다. 다음 예제를 보자.

```javascript
var book = {
  name: "객체지향 자바스크립트의 원리",
  year: 2014
}
```

프로퍼티 이름에는 문자열 리터럴도 사용할 수있는데 문자열 리터럴을 사용하면 공백과 같은 특수 문자도 프로퍼티 이름에 포함할 수 있다.

```javascript
var book = {
  "name": "객체지향 자바스크립트의 원리",
  "year": 2014
}
```

위 코드는 문법적으로는 조금 달라 보여도 앞에서 작성한 코드와 동일하다. 두 예제 모두 논리적으로는 다음 코드와 동일하다.

```javascript
var book = new Object();
book.name = "객체지향 자바스크립트의 원리"
book.year = 2014;
```

앞서 살펴본 세 예제의 결과는 프로퍼티가 두 개 있는 객체가 하나 만들어진다는 점에서 모두 같다. 기능 자체는 결국 똑같기 때문에 어떤 패턴을 선택할지는 여러분에게 달려있따.

*배열 리터럴(array literal)*을 정의하는 방법도 비슷하다. 각 괄호 안에 여러 값을 추가하는데 각 값은 쉼표로 구분한다. 다음 예제를 보자.

```javascript
var colors =["red", "blue", "green"];
console.log(colors[0]); // "red"
```

이 코드는 다음 코드와 동일하다.

```javascript
var colors = new Array("red", "blue", "green")
console.log(colors[0]); // "red"
```

### 함수 리터럴

함수는 보통 리터럴 형식을 사용해 정의된다. 코드 문자열은 실제 코드에 비해 유지보수, 가독성, 디버그 등 여러 면에서 불리하기 떄문에 사실 Functoin 생성자를 사용하는 방법은 그리 권장되지 않는다. 이 때문에 Function 생성자를 사용한 코드는 찾아보기 어렵다.

리터럴 형식을 사용해서 함수를 정의하면 더 쉽고 에러가 발생할 확률도 줄어든다. 다음 코드를 보자.

```javascript
function reflect(value) {
  return value;
}
// 위 코드는 다음과 같다.

var reflect = new Function("value", "return value");
```

이 코드는 reflect() 함수를 정의하고 있는데 이 함수는 전달받은 값을 그대로 반환한다. 이처럼 간단한 함수일 때도 생성자를 사용하는 방법보다 리터럴을 사용하는 방법이 작성하기도 편하고 이해하기도 수비다. 게다가 생성자 형태로 작성한 ㅎ마수는 디버그하기 까다롭다. 자바스크립트 디버거는 생성자를 통해 작성된 함수를 인식하지 못하므로 이렇게 작성된 함수는 들여다 볼 수 없다.


### 정규 표현식 리터럴

자바스크립트에는 RegExp 생성자를 사용하지 않고 정규 표현식을 정의할 수 있는 정규 표현식 리터럴(regular expression literal)도 있다. 정규 표현식 리터럴을 펄(Perl)의 정규표현식과 모습이 매우 비슷하다. 슬래시 두 개 사이에 패턴을 입력하고 추가 설정은 두 번째 슬래시 뒤에 문자 한 개로 표현한다. 다음 예제를 보자.

```javascript
var numbers = /\d+\g;

// 위 코드는 아래 코드와 같다.
 var numbers = new RegExp("\\d+", "g");
```

자바스크립트에서 사용하는 정규 표현식의 리터럴 형식은 문자열 안에 있는 문자를 어떻게 이스케이프 해야 할지 고민할 필요가 없기 때문에 조금 더 다루기 수월하다. RegExp 생성자를 사용하면 패턴을 문자열 인수로 전달해야 하기 떄문에 백슬래시도 이스케이프 해주어야 한다(이 때문에 리터럴에서는 \d를 사용하지만 생성자에서는 \\d를 사용한다). 자바스크립트에서는 대체로 생성자 형식보다 정규표현식 리터럴이 더 많이 사용되지만 문자열 여러 개를 합쳐서 정규 표현식을 만들어야 할 때는 생성자 형식이 더 즐겨 사용된다.

