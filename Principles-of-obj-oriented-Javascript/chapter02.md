# 함수
1장에서 보았듯 자바스크립트에서 함수는 객체이다. 다른 객체에는 없는 함수만의 특성을 꼽으라면 [[call]] 이라는 내부 속성을 뜰 수있다. 내부 속성은 코드로 접근할 수는 없지만 코드의 동작을 정의한다. 자바스크립트에는 ECMAScript에서 정한 여러 객체 내부 속성이 있는데 이러한 내부 속성은 각괄호를 두 개 겹친 표기법으로 표시한다. 

[[call]]은 함수에만 있는 속성으로 객체가 실행될 수 있는지 없는지 판단한다. 이 속성은 함수에만 있기 때문에 ECMAScript에서는 어떤 객체든 [[call]] 속성을 포함하고 있으면 typeof 연산자를 사용했을 때 “function”을 반환하도록 정의했다. 예전에는 일부 브라우저가 정규 표현식 객체에도 [[Call]] 속성을 포함하는 바람에 정규 표현식 객체가 함수인 것처럼 나타나는 문제가 있었다. 하지만 지금은 정규 표현식 객체에 typeof 연산자를 사용할 때 “function” 이라고 반환하는 브라우저가 없다.

이 장에서는 자바스크립트에서 함수를 정의하고 사용하는 다양한 방법에 대해 다루어 보겠다. 자바스크립트에서 함수는 객체이기 때문에 다른 언어와는 조금 다르게 동작하며, 이러한 동작을 잘 이해해야 자바스크립트라는 언어를 잘 이해할 수 있다.

## 선언 vs. 표현식
함수에는 두 가지 리터럴 형태가 있다. 첫 번째는 function 키워드와 바로 뒤에 적는 함수 이름을 사용하는 함수 선언(function declaration)이다. 함수의 내용은 다음과 같이 여닫는 중괄호 사이에 입력한다.

```javascript
function add(num1, num2) {
  return num1 + num2;
}
```

두 번째는 function 키워드 다음에 이름을 적지 않아도 되는 함수 표현식(function expression)이다. 이렇게 작성한 함수는 함수 객체 자체에 이름이 없어 익명 함수(anonymous function)라고도 한다. 함수 표식은 일반적으로 다음고 ㅏ같이 변수나 속성에 참조된다.

```javascript
var add = function(num1, num2) {
  return num1 + num2;
};
```

이 코드는 함수값을 add라는 변수에 할당한다. 함수 표현식은 일므이 없고, 끝에 세미콜론이 있다는 점만 제외하면 함수 선언과 거의 동일하다. 할당 표현식에는 보통 다른 값을 할당할 때와 마찬가지로 끝에 세미콜론을 추가한다.

앞서 살펴본 두 형태는 매우 비슷하지만 한 가지 중요한 차이점이 있다. 함수 선언은 코드가 실행될 때 컨텍스트(선언된 함수를 포함하고 있는 함수 스코프 또는 전역 스코프) 상단에 끌어올려진다. 다시 말해 함수를 호출하는 코드가 함수를 선언한 코드보다 앞에 있어도 에러가 발생하지 않는다는 뜻이다. 예를 들어 다음 코드를 보자.

```javascript
var result = add(5, 5);
function add(num1, num2) {
  return num1 + num2;
};
```

이 코드를 실행하면 에러가 발생할 것 같지만 문제없이 잘 동작한다. 자바스크립트 엔진이 함수 선언을 끌어올려서 마치 다음과 같이 작성된 코드처럼 실행하기 때문이다.

```javascript
// 자바스크립트 엔진이 해석한 코드

function add(num1, num2) {
  return num1 + num2;
};

var result = add(5, 5);

```


함수 호이스팅은 함수 이름을 먼저 처리하기 때문에 일어나는 현상이므로 함수 선언에만 적용된다. 함수 표현식은 변수를 통해서만 함수를 참조하기 때문에 호이스팅 되지 않는다.
따라서 다음 코드를 실행하면 에러가 발생한다.

```javascript
// 에러!
var result = add(5,5);
var add = function(num1, num2) {
  return num1 + num2;
};
```

함수를 호출하기 전에 실행하는 것이라면 함수 선언과 함수 표현식 중 무엇이든 사용할 수 있다. 

## 값으로서의 함수

자바스크립트에는 일급 함수가 있기 때문에 함수를 다른 객체처럼 다룰 수 ㅇ있다. 즉 함수를 변수에 할당할 수도 있고 객체에 추가할 수도 있으며 다른 함수에 인수로 전달하거나 함수에서 함수를 반환할 수도 있다. 참조 값을 쓸 수 있는 곳이라면 어디든 함수도 사용할 수 있다. 이러한 특성 덕분에 자바스크립트 함수는 상당히 유용하다. 다음 예제를 살펴보자.

```javascript
function sayHi() {
  console.log("Hi!");
}

sayHi(); // Hi!

var sayHi2 = sayHi;

sayHi2(); // Hi!
```

이 코드에는 sayHi라는 함수를 만드는 함수 선언이 있다. 그 후에 만들어진 sayHi2 라는 변수에는 sayHi의 값을 할당했다. sayHi와 sayHi2는 이제 같은 함수를 가리킨다. 둘 다 실행할 수 있으며 결과도 같을 것이다. 어떻게 이런 결과에 이르는지 이해하기 위해 Function 생성자를 사용해 코드를 다시 작성해보았다.

```javascript
var sayHi = new Function("console.log(\"Hi!\");");
sayHi(); // Hi!

var sayHi2 = sayHi;
sayHi2(); // Hi!
```

Function 생성자를 사용한 덕분에 다른 객체가 전달되듯 sayHi에 함수 값이 전달되었음을 명확히 알 수 있다. 함수도 객체라는 사실을 염두에 두고 있으면 상당히 많은 동작을 작성할 수 있다. 예를 들어 함수를 다른 함수에 인수로 전달할 수 있다. 자바스크립트 배열의 sort()메소드에는 비교 함수를 인수로 전달할 수 있다(생략도 가능). 비교 함수는 배열에 있는 두 값을 비교할 때 호출되는데 만약 첫 번째 값이 두 번째 값보다 작으면 비교 함수에서는 음수를 반환해야 함다. 반면 첫 번째 값이 두 번째 값보다 크면 양수를 반환해야 하고 두 값이 같을 때는 0을 반환해야 한다.

비교 함수를 전달하지 않으면 sort()는 배열에 있는 원소를 모두 문자열로 변환한 후 문자열을 비교한다. 이 때문에 숫자 배열을 정렬할 때 비교 함수를 사용하지 않으면 잘못된 결과가 나올 수 있다. 따라서 숫자 배열을 올바르게 정렬하려면 다음과 같이 비교 함수를 전달해야 한다.
