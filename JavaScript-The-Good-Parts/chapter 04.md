# 함수

자바스크립트에서 가장 좋은 점 중 하나는 함수의 구현 부분입니다. 자바스크립트에서 함수는 거의 대부분 제대로 된 특성들로 이루어져 있습니다. 하지만 예쌍할 수 있는 것처럼 모든 부분이 그런 것은 아닙니다.

함수는 실행 문장들의 집합을 감싸고 있습니다. 함수는 자바스크립트에서 모듈화의 근간입니다. 함수는 코드의 재사용이나 정보의 구성 및 은닉 등에 사용하고, 객체의 행위를 지정하는데도 사용합니다. 일반적으로 프로그래밍 기술은 요구사항의 집합을 함수와 자료구조의 집합으로 변환하는 것입니다.

## 함수 객체

자바스크립트에서 함수는 객체입니다. 객체는 앞서도 설명한 것처럼 프로토타입 객체로 숨겨진 연결을 갖는 이름/값 쌍들의 집합체입니다. 객체 중에서 객체 리터럴로 생성되는 객체는 `Object.prototype`에 연결됩니다. 반면에 함수 객체는 `Function.prototype`에 연결됩니다(Function은 Object.prototype에 연결됩니다). 또한 모든 함수는 숨겨져 잇는 두 개의 추가적인 속성이 있는데, 이 속성들은 함수의 문맥(context)과 함수의 행위를 구현하는 코드(code)입니다.

또한 모든 함수 객체는 prototype이라는 속성이 있습니다. 이 속성의 값은 함수 자체를 값으로 갖는 constructor라는 속성이 있는 객체입니다. 이는 `Function.prototype`으로 숨겨진 연결과는 구분됩니다.

함수는 객체이기 대문에 다른 값들처럼 사용할 수 있습니다. 함수는 변수나 객체, 배열 등에 저장되며, 다른 함수에 전달하는 인수로도 사용하고, 함수의 반환값으로도 사용합니다. 

함수를 다른 객체와 구분짓는 특징은 호출할 수 있다는 것입니다.

## 함수 리터럴

함수 객체는 함수 리터럴로 생성할 수 있습니다.

```javascript
// add라는 변수를 생성하고 두 수를 더하는 함수를 이 변수에 저장
var add = function (a, b) {
  return a + b;
};
```

함수 리터럴에는 네 가지 부분이 있습니다. 첫 번째 부분은 function이라는 예약어입니다.

두 번째 부분은 선택사항으로 함수의 이름입니다. 함수의 이름은 함수를 재귀적으로 호출할 때 사용하며, 디버거나 개발 툴에서 함수를 구분할 때도 사용합니다. 앞선 예처럼 함수의이름이 주어지지 않은 경우 익명함수(anonymous)라고 부릅니다.

세 번째 부분은 괄호로 둘러싸인 함수의 매개변수 집합니다. 괄호 안에 아예 없거나 하나 이상의 매개변수를 쉼표로 분리해서 열거합니다. 이 매개변수들은 함수 내에서 변수로 정의합니다. 일반적인 변수들을 undefined로 초기화하는 것과는 달리 매개변수는 함수를 호출할 떄 넘겨진 인수로 초기화합니다.

네 번째 부분은 중괄호로 둘러싸인 문장들의 집합입니다. 이러한 문장들은 함수의 몸체(body)이며 함수를 호출했을 때 실행합니다.

함수 리터럴은 표현식이 나올 수 있는 곳이면 어디든지 위치할 수 있습니다. 함수는 다른 함수 내에서도 정의할 수 있습ㄴ디ㅏ. 물론 이러한 내부 함수도 매개변수와 변수를 가질 수 있으며 자신을 포함하고 있는 함수의 매개변수와 변수에도 접근할 수 이씃ㅂㄴ디ㅏ. 함수 리터럴로 생성한 함수 객체는 외부 문맥으로의 연결이 있는데 이를 클로저(closure)라고 합니다. 클로저는 강력한 표현력의 근원입니다.

## 호출

함수를 호출하면 현재 함수의 실행을 잠시 중단하고 제어를 매개변수와 함께 호출한 함수로 넘깁니다. 모든 함수는 명시되어 있는 매개변수에 더해서 this와 arguments라는 추가적인 매개변수 두 개를 받게 됩니다. this라는 매개변수는 객체지향 프로그래밍 관점에서 매우 중요하며, 이 매개변수의 값은 호출하는 패턴에 의해 결정됩니다. 자바스크립트에는 함수를 호출하는데 메소드 호출 패턴, 함수 호출 패턴, 생성자 호출 패턴, apply 호출 패턴이라는 네 가지 패턴이 있습니다. 각각의 패턴에 따라 this라는 추가적인  매개변수를 다르게 초기화합니다. 

함수를 호출하는 호출 연산자는 함수를 나타내는 표현식 뒤에 이어지는 한 쌍의 괄호입니다. 괄호 안에는 표현식을 포함하지 않거나, 하나나 또는 쉼표로 구분해서 둘 이상의 표현식을 포함합니다. 각각의 표현식은 인수값 하나를 산출합니다 .각각의 인수값을 함수의 매개변수에 각각 할당합니다. 

### 메소드 호출 패턴

함수를 객체의 속성에 저장하는 경우 이 함수를 메소드라고 부릅니다. 메소드를 호출할 때, this는 메소드를 포함하고 있는 객체에 바인딩됩니다(즉, this는 객체 자체가 됩니다). 호출되는 표현식이 세부지정(마침표나 [])을 포함하고 있으면 이 방법이 메소드 호출 패턴입니다.

```javascript
// value와 increment 메소드가 있는 myObject 생성.
// increment 메소드의 매개변수는 선택적
// 인수가 숫자가 아니면 1이 기본값으로 사용됨.

var myObject = {
  value: 0,
  increment: function (inc) {
    this.value += typeof inc === 'number' ? inc : 1;
  }
};

myObject.increment();
document.writeln(myObject.value);    // 1

myObject.increment(2);
document.writeln(myObject.value);    // 3
```

메소드는 자신을 포함하는 객체의 속성들에 접근하기 위해서 this를 사용할 수 있습니다. 즉 this를 사용해서 객체의 값을 읽거나 변경할 수 있습니다. this와 객체의 바인딩은 호출 시에 일어납니다. 이렇게 매우 늦은 바인딩은 this를 효율적으로 사용하는 함수를 만들 수 있습니다. 자신의 문맥을 this로 얻는 메소드를 퍼블릭(public) 메소드라고 부릅니다.


### 함수 호출 패턴

함수가 객체의 속성이 아닌 경우에는 함수로서 호출합니다.

```javascript
var sum = add(3, 4);     // 합은 7
```

함수를 이 패턴으로 호출할 때 this는 전역객체에 바인딩됩니다. 이런 특성은 언어 설계 단계에서의 실수입니다. 만약 언어를 바르게 설계했다면, 내부 함수를 호출할 때 이 함수의 this는 외부 함수의 this 변수에 바인딩 되어야 합니다. 이러한 오류의 결과는 메소드가 내부 함수를 사용하여 자신의 작업을 돕지 못한다는 것입니다. 왜냐하면, 내부 함수는 메소드가 객체 접근을 위해 사용하는 this에, 자신의 this를 바인딩하지 않고 엉뚱한 값(전역객체)에 연결하기 때문입니다. 다행히도 이러한 문제를 해결하기 위한 쉬운 대안이 있습니다. 그 대안은 메소드에서 변수를 정의한 후 여기에 this를 할당하고, 내부 함수는 이 변수를 통해서 메소드의 this에 접근하는 방법입니다. 관례상 이 변수의 이름을 that이라고 하면 다음의 예와 같이 구현할 수 있습니다.

```javascript
myObject.double = function() {
  var that = this;  // 대안

  var helper = function () {
    that.value = add(that.value, that.value);
  };

  helper();   // helper를 함수로 호출
};

// double을 메소드로 호출

myObject.double();
document.writeln(myObject.getValue());    // 6
```

### 생성자 호출 패턴

자바스크립트는 프로토타입에 의해서 상속이 이루어지는 언어입니다. 이 말은 객체가 자신의 속성들을 다른 객체에 바로 상속할 수 있다는 뜻입니다. 자바스크립트는 클래스가 없습니다.

이러한 특성은 현존하는 언어들의 경향과는 조금 다른 급진적인 것입니다. 오늘날 대부분의 언어는 클래스를 기반으로 하고 있습니다. 프로토타입에 의한 상속은 매우 표현적이지만 널리 알려지 있지 않습니다. 자바스크립트 자체도 자신의 프로토타입적 본성에 확신이 없었던지, 클래스 기반의 언어들을 생각나게 하는 객체 생성 문법을 제공합니다. 클래스 기반의 프로그래밍에 익숙한 프로그래머들에게 프로토타입에 의한 상속은 받아들여지지 못했고, 클래스를 사용하는 듯한 구문은 자바스크립트의 진정한 프로타입적 속성을 애매하게 만들었습니다. 이는 양쪽에게 모두 최악의 결과라고 할 수 있습니다.

함수를 new라는 전치 연산자와 함께 호출하면, 호출한 함수의 prototype 속성의 값에 연결되는 (숨겨진) 링크를 갖는 객체가 생성되고, 이 새로운 객체는 this에 바인딩 됩니다.

new 라는 전치 연산자는 return 문장의 동작을 변경합니다.

```javascript
// Quo 라는 생성자 함수를 생성
// 이 함수는 status라는 속성을 가진 객체를 생성함

var Quo = function (string) {
  this.status = string;
};

// Quo의 모든 인스턴스에 get_status라는 public 메소드를 줌.

Quo.prototype.get_status = function () {
  return this.status;
};

// Quo의 인스턴스 생성

var myQuo = new Quo("confused");

document.writeln(myQuo.get_status()); // confused
```

new라는 전치 연산자와 함께 사용하도록 만든 함수를 생성자(constructor)라고 합니다. 일반적으로 생성자는 이니셜을 대문자로 표기하여 이름을 지정합니다. 생성자를 new 없이 호출하면 컴파일 시간이나 실행시간에 어떠한 경고도 없어서 알 수 없는 결과를 초래합니다. 그러므로 대문자 표기법을 사용하며 해당 함수가 생성자라고 구분하는 것은 매우 중요합니다.

생성자 함수를 사용하는 스타일은 권장 사항이 아닙니다.

### apply 호출 패턴

자바스크립트는 함수형 객체지향 언어이기 때문에, 함수는 메소드를 가질 수 있습니다.

apply 메소드는 함수를 호출할 때 사용할 인수들의 배열을 받아들입니다. 또한 이 메소드는 this의 값을 선택할 수 있도록 해줍니다. apply 메소드에는 매개변수 두 개가 있습니다. 첫 번째는 this에 묶이게 될 값이며, 두 번째는 매개변수들의 배열입니다.

```javascript
// 숫자 두 개를 가진 배열을 만들고 이를 더함

var array = [3, 4];
var sum = add.apply(null, array);
// 합은 7

// status라는 속성을 가진 객체를 만듦.

var statusObject = {
  status: 'A-OK'
};

// statusObject는 Quo.prototype을 상속받지 않지만,
// Quo에 있는 get_status 메소드가 statusObject를 대상으로
// 실행되도록 호출할 수 있음.

var status = Quo.prototype.get_status.apply(statusObject);
// status는 'A-OK'
```

## 인수 배열 (argument)