# 자바스크립트의 좋은 문법들

이번 장에서는 자바스크립트의 좋은 점들에 해당하는 문법을 살펴봅니다. 이 문법들을 살펴봄으로써 언어가 어떻게 구성되었는지 빠르게 확인할 수 있습니다. 각 문법은 철도 다이어그램으로 설명합니다. 


철도 다이어그램을 해석하는 방법은 간단합니다.
  * 왼쪽에서 시작해서 트랙을 따라 오른쪽 끝으로 이동합니다.
  * 오른쪽으로 가다 보면 둥근 도형 안의 리터럴이나 사각형 안에 있는 설명 또는 규칙을 만납니다.
  * 트랙을 따라가는 것이라면 어떠한 경로라도 유효합니다.
  * 트랙을 따라가지 않는 경로는 모두 무효입니다.
  * 양 끝에 세로 막대 하나를 가진 철도 다이어그램은 한 쌍의 토근 사이에 공백을 허용한다는 뜻이며, 세로 막대 두 개가 있는 경우는 그렇지 않다는 뜻입니다.

좋은 점만을 설명하는 이번 장의 문법은 자바스크립트 전체 문법보다 훨씬 간단합니다.

## 공백

공백은 문자를 구분하는 형태나 주석의 형태를 취할 수 있습니다(즉, 주석 역시 공백입니다). 보통 공백은 별로 중요하지 않지만, 때때로 공백을 사용하지 않으면 하나의 토큰으로 묶여버리는 문자들을 분리하기 위해서 필요합니다. 다음은 그 예입니다.

```javascript
var that = this;
```

var와 that 사이에 있는 빈 칸은 제거할 수 없습니다. 하지만 다른 빈 칸들은 제거해도 상관 없습니다.

자바스크립트에서는 `/* */` 형태의 블록 주석과 `//` 형태의 한 줄 주석을 사용할 수 있습니다. 주석은 프로그램의 가독성을 높이기 위해 충분히 사용되는 것이 좋습니다. 주석을 달 떄는 항상 코드에 대해 정확히 설명해야 합니다. 쓸모 없는 주석은 없느니만 못합니다.

블록 주석을 달 때 사용하는 `/* */`는 PL/I 라는 언어에서 비롯된 것입니다. PL/I은 이 이상한 한 쌍을 주석을 위한 기호로 삼았는데 그 이유는  PL/I 프로그램에서는 문자열 리터럴을 제외하고는 이러한 조합이 거의 나타나지 않기 때문입니다. 하지만 자바스크립트에서는 이러한 조합이 정규 표현식 리터럴에서도 나타날 수 있습니다. 그러므로 블록 주석 방법은 안전하지 않다고 볼 수 있습니다. 예를 들어 다음과 같은 코드를 블록 주석으로 주석화하면 구문 오류가 발생합니다.

```javascript
// /*
//  var rm_a = /a*/.match(5);
// */

```

그러므로 가능하면 `/* */` 를 사용하는 대신 `//`를 사용할 것을 권합니다. 이 책에서는 `//`만을 사용하고 있습니다.

## 이름

이름(name)은 하나의 문자나 그 뒤를 이어서 하나 이상의 문자, 숫자, `_`가 붙는 문자열로 문장, 변수, 매개변수, 속성명, 연산자, 라벨 등에 사용합니다. 다음에 나오는 예약어들은 이름(name)이 될 수 없습니다.

```
abstract
boolean break byte
case catch char class const continue
debugger default delete do double
else enum export extends
false final finally float for functiongoto
if implements import in instanceof int interface
long
native new null
package private protected public
return 
short static super switch synbchronized
this throw throws transient true try typeof
var volatile void
while with
```

(이 목록에는 예약어에 꼭 포함될 것 같은 undefined, NaN, Infinity 등은 없습니다.)

여기에 열거된 예약어 대부분은 실제로 언어에서 사용하지 않습니다. 예약어는 변수 이름이나 매개변수 이름으로 사용할 수 없습니다. 게다가 예약어는 객체 리터럴의 속성명이나 객체의 속성을 나타낼 때 사용하는 마침표 다음에 사용할 수 없습니다. 

## 숫자

자바스크립트는 숫자형이 하나만 있습니다. 내부적으로 숫자는 64비트 부동 소수점 형식을 지닙니다. 이는 자바의 double 형과 같습니다. `대부분의 다른 언어와는 달리 자바스크립트에는 정수와 실수의 구분이 없습니다.` 즉, 1과 1.0은 같은 값입니다. 이러한 특성은 매우 편리합니다. short 형을 사용해서 오버플로우가 발생하는 일 등이 전혀 없으며, 단지 알아야 할 것은 숫자형이라는 것뿐입니다. 결국 숫자형 때문에 발생하는 오류 대부분을 피할 수 있습니다. 

숫자 리터럴이 지수 부분을 포함하는 경우 이 숫자 리터럴의 값은 e 앞의 값에다 e 뒤의 값만큼 10을 제곱한 값의 곱이 됩니다. 그래서 100은 1e2와 같습니다. 

음수는 수 앞에 -를 붙이면 됩니다.

`NaN`은 수치 연산을 해서 정상적인 값을 얻지 못할 때의 값입니다. NaN은 그 자신을 포함해서 어떤 값하고도 같지 않습니다. 그러므로 NaN인지 확인하려면 비교 구문이 아니라 isNaN()이라는 함수를 사용합니다.

1.79769313486231570e+308 보다 큰 값은 Infinity로 나타납니다.

숫자는 메소드가 있습니다. 자바스크립트의 `Math`라는 객체에 수치 계산을 위한 메소드가 있습니다. 예를 들어 `Math.floor(number)` 메소드는 수를 정수로 변환할 때 사용합니다. 

## 문자열

문자열은 작은 따옴표나 큰 따옴표로 묶어서 나타내며, 따옴표 안에는 문자 0개 이상을 포함합니다. `\`(백슬래시)는 이스케이프 문자입니다. 자바스크립트는 유니코드가 16비트 문자 셋이었을 때 개발했기 때문에 자바스크립트 내의 모든 문자는 16비트 유니코드입니다.

자바스크립트에는 문자 타입이 없습니다. 그러므로 문자 하나를 나타내기 위해서는 문자 하나만을 포함하는 문자열을 사용해야 합니다. 

이스케이프 시퀀스로 `\`나 따옴표, 제어문자처럼 일반 문자가 아닌 특별한 문자를 문자열에 삽입할 수 있습니다. 

```javascript
"A" === "\u0041"
```

문자열은 length라는 속성이 있습니다. "seven".length의 값은 5입니다.

문자열은 변하지 않습니다(immutable). 일단 문자열이 한번 만들어지면, 이 문자열은 결코 변하지 않습니다. 하지만 여러 문자열을 + 연산자로 연결하여 새로운 문자열을 만들 수 있습니다. 분리된 문자열이 + 연산자로 연결되든 그냥 문자열 하나든 문자들의 순서가 같으면 같은 문자열입니다. 그래서 다음의 예는 참(true)입니다.

```javascript
'c' + 'a' + 't' === 'cat'
```

문자열은 메소드가 있습니다.

```javascript
'cat'.toUpperCase() === 'CAT'
```


## 문장(Statements)

하나의 컴파일 단위에는 실행을 위한 문장들이 포함돼 있습니다. 웹 브라우저에서 각각의 `<script>` 태그는 컴파일되어 즉시 실행되는 하나의 컴파일 단위입니다. 링커(linker)가 없기 때문에 자바스크립트는 모든 문장을 공통적인 전역 이름 공간(namespace)에 한 데 몰아 넣습니다. 전역 변수에 관한 좀더 자세한 부분은 부록 A에서 설명합니다.

var 문은 함수 내부에서 사용될 때 함수의 private 변수를 정의합니다.

switch 문, while 문, for 문, do 문에는 break 문에서 사용할 수 있는 라벨을 선택적으로 지정할 수 있습니다.

문장들은 대개 위에서 아래로 순서대로 실행합니다. 이러한 실행 순서는 조건문(if, switch)이나 반복문(while, for, do)또는 실행 흐름을 벗어나는 문장(break, return, throw)이나 함수 호출로 변경할 수 있습니다.

블록은 중괄호로 쌓인 문장들의 집합입니다. 다른 언어들과 달리 자바스크립트에서 블록은 새로운 유효범위를 생성하지 않습니다. 이러한 이유로 변수는 블록 안에서가 아니라 함수의 첫 부분에서 정의해야 합니다.

if 문은 표현식의 값에 따라 프로그램의 흐름을 변경합니다. then 블록은 표현식이 참일 때 실행하며, 표현식이 거짓인 경우에는 else 블록을 실행합니다. (물론 else 블록은 선택적입니다).

다음은 거짓에 해당하는 값들입니다.
  * false
  * null
  * undefined
  * 빈 문자열 ''
  * 숫자 0
  * NaN

이 외의 모든 값은 참입니다. 예를 들어 true, 문자열 'false', 모든 객체 등은 모두 참입니다.

- switch 문은 다중 분기를 수행합니다. 이 문장은 표현식과 모든 case 문의 표현 식이 같은지를 비교합니다. 표현식의 결과값은 숫자일수도 있고 문자열일수도 있습니다. 일치하는 표현식을 찾으면 해당 case 절에 잇는 문장들을 실행합니다. 만약 일치하는 표현식을 찾지 못하는 경우에는 default 절의 문장들을 실행합니다

- case 절은 하나 이상의 case 문을 포함합니다. case 절의 표현식은 꼭 상수일 필요가 없습니다. case 절의 문장 마지막에는 다음 case 절로 넘어가지 않게 실행 흐름을 벗어나는 문장을 사용해야 합니다. 이를 위해 break 문을 사용할 수 있습니다. 

- while 문은 단순한 반복 수행 문장입니다. 표현식이 참인 동안은 블록을 반복해서 실행하며, 표현식이 거짓이면 반복 수행은 끝납니다.

- for문은 좀더 복잡한 반복문입니다. 이 실행문은 두 가지 형식으로 사용합니다. 일반적인 형식은 초기화, 조건, 증가 라는 세가지 절로 제어하는 구조입니다(다이어그램에서 볼 수 있는 것처럼 이 세가지 절은 모두 선택적입니다). 먼저 초기화를 실행합닏. 보통 이 부분에서 반복 횟수를 제어하는 변수를 초기화합니다. 그 다음에 조건 부분이 만족하는지를 검사합니다. 이 검사의 전형적인 형태는 반복 횟수를 제어하는 변수가 조건에 만족하는지를 확인하는 것입니다. 만약 조건부분이 생략되면 참으로 간주합니다. 조건 부분의 검사 결과가 거짓이면 반복을 종료합니다. 조건을 만족해서 블록을 한 번 실행하면 증가 부분을 실행하고 다시 조건 검사를 반복합니다. 

- 또 다른 for 문의 형식은 객체의 속성이름(또는 키)을 열거하는 것입니다(이러한 형식을 for in이라고 부릅니다). 각각의 반복 실행마다 객체에 있는 각각의 속성 이름을 변수에 할당합니다. 이 for in 형식은 보통 다음과 같이 `object.hasOwnProperty`(변수) 메소드로 속성 이름이 실제로 객체의 속성인지 아니면 프로토타입 체인(prototype chain) 상에 있는 것인지를 확인하는 것이 필요합니다.

```javascript
for (myvar in obj) {
  if (obj.hasOwnProperty(myvar)) {
    ...
  }
}
```

- do 문은 표현식이 블록을 실행하기 전이 아니라 실행한 후에 검사된다는 점만 빼면 while 문과 같습니다. 이러한 특성 때문에 do문은 적어도 한 번 블록을 실행합니다

- try 문은 블록을 실행하면서 블록 내에서 발생하는 예외 상황을 포착합니다. catch절은 예외 객체를 받는 새로운 변수를 정의합니다.

- throw 문은 예외를 발생합니다. 만약 throw 문이 try 블록 안에 있으면 실행의 제어는 catch 절로 이동합니다. 만약 throw 문이 일반적인 함수 내에 있다면 함수 호출은 중단되고 함수를 호출한 try 문의 catch 절로 실행 흐름이 이동합니다.

표현식 부분은 보통 name과 message라는 속성이 있는 객체 리터럴입니다. 예외를 포착한 곳에서는 이 객체의 정보로 무엇을 수행할지 결정할 수 있습니다.

return 문은 함수에서 호출한 곳으로 되돌아가는 역할을 합니다. 또한 이 문장은 반환값을 지정합니다. 표현식이 지정되지 않으면 undefined를 반환합니다.

자바스크립트는 return과 표현식 부분 사이에 줄 바꿈을 허용하지 않습니다.

break 문은 반복문이나 switch 문에서 흐름을 벗어나게 하는 역할을 합니다. 이 문장은 라벨 이름을 취할 수 잇는 데 라벨이 주어지면 라벨이 붙은 문장의 끝으로 이동합니다.

자바스크립트는 break와 라벨 사이에 줄 바꿈을 허용하지 않습니다.

표현식 문장은 값을 하나 이상의 변수나 객체의 속성에 할당하거나 메소드를 호출하고 객체의 속성을 삭제할 수 있습니다. = 연산자는 할당하는 데 사용합니다. 할당 연산자를 동등 연산자인 ===와 혼동해서는 안 됩니다. += 연산자는 더하거나 연결합니다.

## 표현식 (Expressions)

가장 간단한 표현식은 리터럴 값(문자열이나 숫자), 변수 내장값들(`true, false, null, undefined, NaN, Infinity 등`), new 키워드에 의한 호출 표현식, delete 키워드 다음에 나오는 세부 지정 표현식, 괄호로 쌓인 표현식, 전치 연산자 다음에 이어지는 표현식 등입니다. 그리고 그 외에도 다음과 같은 표현식이 있습니다.

* 이항 연산자의 표현식
* ? 삼항 연산자의 표현식
* 호출
* 세부지정(. 또는 [])

? 삼항 연산자는 3개의 피연산자를 취합니다. 첫 번째 피연산자가 참이면, 두 번재 피연산자가 값이 되지만, 첫 번째 피연산자가 거짓인 경우에는 세 번째 피연산자가 값이 됩니다.

[표 2-1] 목록에서 상위에 있는 연산자일수록 우선 순위가 높습니다. 괄호를 사용하면 일반적인 우선 순위를 변경하여 높은 우선 순위를 갖게 할 수 있습니다. 다음은 그 예입니다.

```
2 + 3 * 5 === 17
```

```
(2 + 3) * 5 === 25
```



|                         |               |
| ----------------------- | ------------- |
| .[] ()                  | 세부지정이나 호출     |
| delete new typeof + - ! | 단항 연산자        |
| * / %                   | 곱하기, 나누기, 나머지 |
| + -                     | 더하기/연결, 빼기    |
| >= <= > <               | 같지 않음 비교      |
| === !==                 | 동등            |
| &&                      | 논리적 and       |
| \|\|                    | 논리적 or        |
| ?:                      | 삼항            |


`typeof 연산자`의 결과값에는 number, string, boolean, undefined, function , object 등이 있습니다. 피연산자가 배열이나 null이면 결과는 모두 object인데 이는 약간 문제가 있습니다.

`! 연산자`의 피연산자 값이 참이면 결과값은 거짓이며 그 반대면 결과값은 참입니다.

`+ 연산자`는 수를 더하거나 문자열을 연결합니다. 더하기 연산을 원하는 경우에는 반드시 피연산자 두 개가 모두 숫자여야 합니다.

`/ 연산자`는 피연산자 두 개가 모두 정수형이어도 결과값이 실수일 수 있습ㄴ디ㅏ.

`&& 연산자`는 첫 번째 피연산자가 거짓일 경우 첫 번째 피연산자의 값을 취하고, 그렇지 않은 경우에는 두 번째 피연산자 값을 결과값으로 취합니다.

`|| 연산자`는 &&와 반대로 첫 번째 피연산자가 참이면 이 값을 취하고 그렇지 않으면 두 번째 피연산자를 결과값으로 취합니다.

호출은 함수를 실행합니다. 호출 연산자는 함수 이름 뒤에 이어지는 한 쌍의 괄호입니다. 괄호 내에는 함수에 전달하는 인수를 포함할 수 있습니다.

세부지정은 객체의 속성이나 배열의 구성요소를 지정할 때 사용합니다

## 리터럴(Literals)

객체 리터럴은 새로운 객체를 생성할 때 편리한 표기법입니다. 속성명은 이름이나 문자열로 지정할 수 있습니다. 속셩명은 변수가 아니라 리터럴 이름이기 때문에 객체의 속성명은 반드시 컴파일 시에 알려져야 합니다. 속성의 값은 표현식입니다. 객체 리터럴은 다음 장에서 자세히 살펴봅니다.

배열 리터럴은 새로운 배열을 생성할 때 편리한 표기법입니다.

## 함수(Function)

함수 리터럴은 함수값을 정의합니다. 함수 리터럴은 이름을 가질 수 있는데 이 이름은 자신을 재귀적으로 호출할 떄 사용할 수 있습니다. 또한 함수 리터럴은 매개변수 목록을 가질 수 있는데 이 매개변수는 함수 호출 시 넘어온 인수로 초기화되는 변수입니다. 함수 몸체는 변수 정의와 문장들을 포함합니다.



































